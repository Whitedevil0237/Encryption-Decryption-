<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AES-GCM Encryption Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:Arial;padding:18px;background:#f3f6fb}
    .box{max-width:760px;margin:12px auto;background:#fff;padding:18px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.06)}
    label{display:block;margin-top:10px;font-weight:600}
    textarea,input{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ccc;box-sizing:border-box}
    button{margin-top:10px;padding:8px 12px;border:0;border-radius:6px;background:#2563eb;color:#fff;cursor:pointer}
    button.alt{background:#6b7280}
  </style>
</head>
<body>
  <div class="box">
    <h2>AES-GCM Encryption (Password-derived key)</h2>
    <label for="aesText">Plaintext</label>
    <textarea id="aesText" rows="3">Hello AES-GCM!</textarea>

    <label for="aesPassword">Password (any)</label>
    <input id="aesPassword" type="password" value="mypassword" />

    <div style="margin-top:10px">
      <button id="encBtn">Encrypt → produce Base64</button>
      <button id="decBtn" class="alt">Decrypt ← from Base64</button>
    </div>

    <label for="aesResult">Result (base64: salt|iv|cipher)</label>
    <textarea id="aesResult" rows="3" readonly></textarea>

    <p style="margin-top:12px;color:#555;font-size:13px">
      Notes: The encrypted result encodes salt + iv + ciphertext so decrypt needs only the password and that base64 string.
      Open the page over <strong>http://localhost</strong> or HTTPS for Web Crypto to work reliably.
    </p>
  </div>

  <script>
    // --- Helpers ---
    const enc = new TextEncoder();
    const dec = new TextDecoder();

    // safe base64 <-> ArrayBuffer
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }
    function base64ToArrayBuffer(base64) {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    // derive key from password using PBKDF2
    async function getKeyFromPassword(password, salt) {
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: salt, iterations: 150000, hash: "SHA-256" },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    // --- Encryption: generate random salt + iv, derive key, encrypt, return base64(salt|iv|ct) ---
    async function encryptAES_GCM(plaintext, password) {
      if (!password) throw new Error("Password required");
      const salt = crypto.getRandomValues(new Uint8Array(16)); // 128-bit salt
      const iv = crypto.getRandomValues(new Uint8Array(12));   // 96-bit iv (recommended)
      const key = await getKeyFromPassword(password, salt);
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, enc.encode(plaintext));
      // combine salt + iv + ciphertext
      const combined = new Uint8Array(salt.byteLength + iv.byteLength + ct.byteLength);
      combined.set(salt, 0);
      combined.set(iv, salt.byteLength);
      combined.set(new Uint8Array(ct), salt.byteLength + iv.byteLength);
      return arrayBufferToBase64(combined.buffer);
    }

    // --- Decryption: parse salt+iv+ct, derive key, decrypt ---
    async function decryptAES_GCM(base64Combined, password) {
      if (!password) throw new Error("Password required");
      const combinedBuf = base64ToArrayBuffer(base64Combined);
      const combined = new Uint8Array(combinedBuf);
      if (combined.length < 16 + 12) throw new Error("Invalid data length");
      const salt = combined.slice(0, 16);
      const iv = combined.slice(16, 28);
      const ct = combined.slice(28).buffer;
      const key = await getKeyFromPassword(password, salt);
      const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, ct);
      return dec.decode(plainBuf);
    }

    // --- UI wiring ---
    const encBtn = document.getElementById('encBtn');
    const decBtn = document.getElementById('decBtn');
    const aesText = document.getElementById('aesText');
    const aesPassword = document.getElementById('aesPassword');
    const aesResult = document.getElementById('aesResult');

    encBtn.addEventListener('click', async () => {
      try {
        const pt = aesText.value;
        const pw = aesPassword.value;
        if (!pt) { alert('Enter plaintext to encrypt'); return; }
        if (!pw) { alert('Enter password'); return; }
        encBtn.disabled = true;
        encBtn.textContent = 'Encrypting...';
        const base64 = await encryptAES_GCM(pt, pw);
        aesResult.value = base64;
        encBtn.textContent = 'Encrypt → produce Base64';
      } catch (err) {
        console.error(err);
        alert('Encryption error: ' + (err.message || err));
      } finally { encBtn.disabled = false; }
    });

    decBtn.addEventListener('click', async () => {
      try {
        const b64 = aesResult.value.trim();
        const pw = aesPassword.value;
        if (!b64) { alert('Paste the Base64 result into the Result field'); return; }
        if (!pw) { alert('Enter password'); return; }
        decBtn.disabled = true;
        decBtn.textContent = 'Decrypting...';
        const plain = await decryptAES_GCM(b64, pw);
        aesText.value = plain;
        decBtn.textContent = 'Decrypt ← from Base64';
      } catch (err) {
        console.error(err);
        alert('Decryption error: ' + (err.message || err));
        aesText.value = 'Decryption failed — check password & data';
      } finally { decBtn.disabled = false; }
    });

    // Helpful runtime log if crypto isn't available
    if (!window.crypto || !crypto.subtle) {
      console.error('Web Crypto API not available. Ensure secure context (https or localhost).');
      alert('Web Crypto API not available. Open this page over https or http://localhost.');
    }
  </script>
</body>
</html>
